/*   csi_radar.c
 *  功能：
 *  1. 上电自动连接 Wi-Fi（使用 example_connect）
 *  2. 连接成功后等待用户按下 BOOT 键(GPIO0)，低电平有效
 *  3. 按键触发后倒计时 10 s，倒计时 log 实时输出
 *  4. 倒计时结束后进入“CSI 校准”阶段，校准时间可由变量 CALIB_TIME_SEC 设定
 *  5. 校准完成后自动：
 *     – 启动 Ping（或 NULL 数据）保持 CSI 更新
 *     – 启动雷达算法实时判断：房间有人/无人、静止/运动
 *     – 所有结果通过 ESP_LOGI 打印
 *
 *  代码在官方示例基础上裁剪、合并，保留全部 CLI 功能。
 */
#include "doit_csi.h"

static const char *TAG = "Doit_Csi";

// 添加状态计数器
static uint32_t s_state_count = 0;
static uint32_t s_state_change = false;

/**
 * ping触发路由发送任务
 */
static void trigger_router_send_data_task(void *arg)
{
    wifi_radar_config_t radar_config = {0};
    wifi_ap_record_t ap_info = {0};
    uint8_t sta_mac[6] = {0};

    esp_radar_get_config(&radar_config);
    esp_wifi_sta_get_ap_info(&ap_info);
    ESP_ERROR_CHECK(esp_wifi_get_mac(WIFI_IF_STA, sta_mac));

    // 打印 AP 信息
    ESP_LOGI(TAG, "AP Information:");
    ESP_LOGI(TAG, "SSID: %s", ap_info.ssid);
    ESP_LOGI(TAG, "BSSID: " MACSTR, MAC2STR(ap_info.bssid));
    ESP_LOGI(TAG, "RSSI: %d", ap_info.rssi);
    ESP_LOGI(TAG, "Channel: %d", ap_info.primary);
    ESP_LOGI(TAG, "Authmode: %d", ap_info.authmode);

    radar_config.csi_recv_interval = g_send_data_interval;
    memcpy(radar_config.filter_dmac, sta_mac, sizeof(radar_config.filter_dmac));

#if WIFI_CSI_SEND_NULL_DATA_ENABLE
    ESP_LOGI(TAG, "Send null data to router");

    memset(radar_config.filter_mac, 0, sizeof(radar_config.filter_mac));
    esp_radar_set_config(&radar_config);

    typedef struct
    {
        uint8_t frame_control[2];
        uint16_t duration;
        uint8_t destination_address[6];
        uint8_t source_address[6];
        uint8_t broadcast_address[6];
        uint16_t sequence_control;
    } __attribute__((packed)) wifi_null_data_t;

    wifi_null_data_t null_data = {
        .frame_control = {0x48, 0x01},
        .duration = 0x0000,
        .sequence_control = 0x0000,
    };

    memcpy(null_data.destination_address, ap_info.bssid, 6);
    memcpy(null_data.broadcast_address, ap_info.bssid, 6);
    memcpy(null_data.source_address, sta_mac, 6);

    ESP_LOGW(TAG, "null_data, destination_address: " MACSTR ", source_address: " MACSTR ", broadcast_address: " MACSTR,
             MAC2STR(null_data.destination_address), MAC2STR(null_data.source_address), MAC2STR(null_data.broadcast_address));

    ESP_ERROR_CHECK(esp_wifi_config_80211_tx_rate(WIFI_IF_STA, WIFI_PHY_RATE_6M));

    while (true)
    {
        esp_err_t ret = esp_wifi_80211_tx(WIFI_IF_STA, &null_data, sizeof(wifi_null_data_t), true);
        if (ret != ESP_OK)
        {
            ESP_LOGW(TAG, "esp_wifi_80211_tx, %s", esp_err_to_name(ret));
            vTaskDelay(pdMS_TO_TICKS(1000));
        }

        vTaskDelay(pdMS_TO_TICKS(g_send_data_interval));
    }

#else
    ESP_LOGI(TAG, "Send ping data to router");

    memcpy(radar_config.filter_mac, ap_info.bssid, sizeof(radar_config.filter_mac));
    esp_radar_set_config(&radar_config);

    static esp_ping_handle_t ping_handle = NULL;
    esp_ping_config_t config = ESP_PING_DEFAULT_CONFIG();
    config.count = 0;
    config.data_size = 1;
    config.interval_ms = g_send_data_interval;

    /**
     * @brief Get the Router IP information from the esp-netif
     */
    esp_netif_ip_info_t local_ip;
    esp_netif_get_ip_info(esp_netif_get_handle_from_ifkey("WIFI_STA_DEF"), &local_ip);
    ESP_LOGI(TAG, "Ping: got ip:" IPSTR ", gw: " IPSTR, IP2STR(&local_ip.ip), IP2STR(&local_ip.gw));
    config.target_addr.u_addr.ip4.addr = ip4_addr_get_u32(&local_ip.gw);
    config.target_addr.type = ESP_IPADDR_TYPE_V4;

    esp_ping_callbacks_t cbs = {0};
    esp_ping_new_session(&config, &cbs, &ping_handle);
    esp_ping_start(ping_handle);
#endif

    vTaskDelete(NULL);
}

static void wifi_radar_cb(const wifi_radar_info_t *info, void *ctx)
{
    ESP_LOGI(TAG, "Radar callback triggered, wander=%.6f", info->waveform_wander);
    static float *s_buff_wander = NULL;
    static float *s_buff_jitter = NULL;
    static uint32_t s_buff_count = 0;
    uint32_t buff_max_size = g_console_input_config.predict_buff_size;           //  定义雷达信息缓冲区最大长度和异常值数量
    uint32_t buff_outliers_num = g_console_input_config.predict_outliers_number; //  定义雷达信息缓冲区最大长度和异常值数量
    uint32_t someone_count = 0;
    uint32_t move_count = 0;
    bool room_status = false;  // 房间状态
    bool human_status = false; // 人运动状态

    if (!s_buff_wander)
    {
        s_buff_wander = calloc(RADAR_BUFF_MAX_LEN, sizeof(float)); // 存储雷达检测到的波形漂移（wander）
    }

    if (!s_buff_jitter)
    {
        s_buff_jitter = calloc(RADAR_BUFF_MAX_LEN, sizeof(float)); // 存储雷达检测到的波形抖动（jitter）数据
    }

    s_buff_wander[s_buff_count % RADAR_BUFF_MAX_LEN] = info->waveform_wander; // 将当前检测到的波形漂移（wander）数据存储到缓冲区
    s_buff_jitter[s_buff_count % RADAR_BUFF_MAX_LEN] = info->waveform_jitter; // 将当前检测到的波形抖动（jitter）数据存储到缓冲区
    s_buff_count++;

    if (s_buff_count < buff_max_size) //  如果缓冲区中的数据量小于最大长度，则继续存储
    {
        return;
    }

    extern float trimmean(const float *array, size_t len, float percent); //  声明外部函数，用于计算数组的截断均值
    extern float median(const float *a, size_t len);                      //  声明外部函数，用于计算数组的中位数

    float wander_average = trimmean(s_buff_wander, RADAR_BUFF_MAX_LEN, 0.5); //  计算s_buff_wander数组中去除50%元素后的平均值
    float jitter_midean = median(s_buff_jitter, RADAR_BUFF_MAX_LEN);         //  计算s_buff_jitter数组的中位数

    for (int i = 0; i < buff_max_size; i++)
    {
        uint32_t index = (s_buff_count - 1 - i) % RADAR_BUFF_MAX_LEN;

        if ((wander_average * g_console_input_config.predict_someone_sensitivity > g_console_input_config.predict_someone_threshold)) //  如果wander_average乘以.predict_someone_sensitivity大于预测有人阈值，则someone_count加1
        {
            someone_count++;
        }
        else
        {
            ESP_LOGI(TAG, "wander_average = %f,predict_someone_sensitivity=[%f],predict_someone_threshold=[%f]", wander_average, g_console_input_config.predict_someone_sensitivity, g_console_input_config.predict_someone_threshold);
        }

        if (s_buff_jitter[index] * g_console_input_config.predict_move_sensitivity > g_console_input_config.predict_move_threshold || (s_buff_jitter[index] * g_console_input_config.predict_move_sensitivity > jitter_midean && s_buff_jitter[index] > 0.0002)) //  如果s_buff_jitter数组中当前元素的值乘以预测移动敏感度大于预测移动阈值，或者当前元素的值乘以预测移动敏感度大于jitter_midean且当前元素的值大于0.0002，则move_count加1
        {
            move_count++;
        }
        // else
        // {
        //     ESP_LOGI(TAG, "s_buff_jitter[%lu] = %f,predict_move_sensitivity=[%f],predict_move_threshold=[%f],jitter_midean=[%f]", index, s_buff_jitter[index], g_console_input_config.predict_move_sensitivity, g_console_input_config.predict_move_threshold, jitter_midean);
        // }
    }

    if (someone_count >= 1) //  如果someone_count大于等于1，则说明有人移动
    {
        room_status = true;
    }
    else
    {
        room_status = false;
    }

    if (move_count >= buff_outliers_num) //  如果移动次数大于等于异常值数量，则设置human_status为true
    {
        human_status = true;
    }
    else
    {
        human_status = false;
    }

    static uint32_t s_count = 0;

    if (!s_count)
    {
        ESP_LOGI(TAG, "================ RADAR RECV ================");
        ESP_LOGI(TAG, "type,sequence,timestamp,waveform_wander,someone_threshold,someone_status,waveform_jitter,move_threshold,move_status");
    }

    char timestamp_str[32] = {0};
    sprintf(timestamp_str, "%lu", esp_log_timestamp());

    if (ctx)
    {
        strncpy(timestamp_str, (char *)ctx, 31);
    }

    static uint32_t s_last_move_time = 0;    //  定义一个静态的32位无符号整数变量s_last_move_time，用于记录上次移动的时间
    static uint32_t s_last_someone_time = 0; //  定义一个静态的32位无符号整数变量，用于存储上一次有人操作的时间

    if (g_console_input_config.train_start) //  如果训练开始
    {
        s_last_move_time = esp_log_timestamp(); //  获取当前时间戳，并赋值给s_last_move_time和s_last_someone_time
        s_last_someone_time = esp_log_timestamp();

        // static bool led_status = false;

        // if (led_status)
        // {
        //     ws2812_led_set_rgb(0, 0, 0);
        // }
        // else
        // {
        //     ws2812_led_set_rgb(255, 255, 0);
        // }

        // led_status = !led_status;

        return;
    }

    /**
     * s_count:数据序列号
     * timestamp_str:时间戳
     * info->waveform_wander:当前波形漂移值
     * wander_average:波形漂移的平均值。
     * g_console_input_config.predict_someone_threshold / g_console_input_config.predict_someone_sensitivity，校准后的“有人”阈值。
     * room_status:房间状态,1表示有人。
     * info->waveform_jitter:当前波形抖动值
     * jitter_midean:波形抖动的平均值。
     * jitter_midean / g_console_input_config.predict_move_sensitivity，校准后的“移动”阈值。
     * human_status:，人运动状态（1 表示有人在运动）。
     */
    printf("RADAR_DADA,|s_count=%lu|,|timestamp_str=%s|,|waveform_wander=%.6f|,|wander_average=%.6f|,|after_calib_room_threshold=%.6f|,|room_status=%d|,|waveform_jitter=%.6f|,\r\n|jitter_midean=%.6f|,|after_calib_move_threshold=%.6f|,|human_status=%d|\n", s_count++, timestamp_str,
           info->waveform_wander, wander_average, g_console_input_config.predict_someone_threshold / g_console_input_config.predict_someone_sensitivity, room_status,
           info->waveform_jitter, jitter_midean, jitter_midean / g_console_input_config.predict_move_sensitivity, human_status);

    if (room_status)
    {
        if (human_status)
        {
            // ws2812_led_set_rgb(0, 255, 0);
            ESP_LOGI(TAG, "Someone moved");
            s_last_move_time = esp_log_timestamp();
        }
        else if (esp_log_timestamp() - s_last_move_time > 3 * 1000)
        {
            // ws2812_led_set_rgb(255, 255, 255);
            ESP_LOGI(TAG, "Someone static");
        }

        s_last_someone_time = esp_log_timestamp();
    }
    else if (esp_log_timestamp() - s_last_someone_time > 3 * 1000)
    {
        ESP_LOGI(TAG, "No People");
        if (human_status)
        {
            s_last_move_time = esp_log_timestamp();
            // ws2812_led_set_rgb(255, 0, 0);
        }
        else if (esp_log_timestamp() - s_last_move_time > 3 * 1000)
        {
            // ws2812_led_set_rgb(0, 0, 0);
        }
    }

    // if (room_status != last_room_status || human_status != last_human_status)
    // {
    //     if (g_human_status_cb)
    //     {
    //         g_human_status_cb(room_status, human_status);
    //     }
    //     last_room_status = room_status;
    //     last_human_status = human_status;
    // }

    // 判断状态是否改变
    ESP_LOGI(TAG, "room_status=%d, human_status=%d,last_room_status=%d, last_human_status=%d", room_status, human_status, last_room_status, last_human_status);
    if (room_status != last_room_status || human_status != last_human_status)
    {
        // 如果状态改变，重置计数器
        s_state_count = 1;
        s_state_change = true;
    }
    else
    {
        // 如果状态未改变，计数器加1
        s_state_count++;
        ESP_LOGI(TAG, "state_count=%lu", s_state_count);
    }

    // 如果连续15次状态相同并且是第一次状态改变,则调用回调函数
    if (s_state_count >= 15 && s_state_change)
    {
        if (g_human_status_cb)
        {
            ESP_LOGI(TAG, "状态变化超过15次，执行回调");
            // 重置计数器
            s_state_count = 0;
            s_state_change = false;
            g_human_status_cb(room_status, human_status);
        }
    }

    last_room_status = room_status;
    last_human_status = human_status;
}

/**
 * CSI初始化
 */
void doit_csi_init(void)
{

    /* ---------- 初始化雷达库 ---------- */
    esp_radar_init();
    wifi_radar_config_t radar_config = WIFI_RADAR_CONFIG_DEFAULT();
    radar_config.wifi_radar_cb = wifi_radar_cb;            /* 雷达结果回调 */
    radar_config.csi_recv_interval = g_send_data_interval; // 它决定了“每隔多少毫秒向路由器发一次数据包”，以便触发路由器回包，从而拿到一份新的 CSI 数据。

    // 当宏 WIFI_CSI_SEND_NULL_DATA_ENABLE 被定义成 1 时，才把 dump_ack_en 设为 true，从而让 Wi-Fi 驱动把 ACK（握手应答帧） 的 CSI 也一并采集并上报,普通数据帧（Ping、Null Data）已经能提供 CSI，但 ACK 帧是路由器→ESP32 的下行帧，也能携带 CSI。打开后 CSI 采样量翻倍（上行 + 下行），时间分辨率更高 → 适合做 高精度呼吸/微动检测。
    // radar_config.csi_config.channel_filter_en = true;
#if WIFI_CSI_SEND_NULL_DATA_ENABLE
    radar_config.csi_config.dump_ack_en = true;
#endif

    /* 只接收路由器 CSI，MAC 前缀随意填，后续会被替换 */
    memcpy(radar_config.filter_mac, "\x1a\x00\x00\x00\x00\x00", 6);
    esp_radar_set_config(&radar_config);
}

/* 启动雷达校准 */
bool start_csi_calib(void)
{
    /* 启动雷达训练（校准） */
    SetIsStartCalibRunning(true);
    xTaskCreate(
        trigger_router_send_data_task,
        "trigger_router_send_data", 4 * 1024,
        NULL,
        5,
        &trigger_router_send_data_task_handler);
    esp_err_t ret = esp_radar_start();
    if (ret != ESP_OK)
    {
        ESP_LOGE(TAG, "esp_radar_start failed: %s", esp_err_to_name(ret));
    }
    else
    {
        ESP_LOGI(TAG, "esp_radar_start success");
    }
    ret = esp_radar_train_start();
    if (ret != ESP_OK)
    {
        ESP_LOGE(TAG, "esp_radar_train_start failed: %s", esp_err_to_name(ret));
        return false;
    }
    ESP_LOGI(TAG, "校准开始");
    g_console_input_config.train_start = true;
    return true;
}

/* 关闭雷达校准 */
void stop_csi_calib(void)
{
    /* 停止训练，获取阈值 */
    ESP_LOGI(TAG, "校准完成前，有人阈值=%.6f，运动阈值=%.6f", g_console_input_config.predict_someone_threshold, g_console_input_config.predict_move_threshold);

    /* 停止训练，获取阈值 */
    float someone_thr = 0.0f, move_thr = 0.0f;
    esp_err_t ret = esp_radar_train_stop(&someone_thr, &move_thr);

    if (ret != ESP_OK)
    {
        ESP_LOGE(TAG, "esp_radar_train_stop failed: %s", esp_err_to_name(ret));
        // 这里可以选择重试或重新校准，先return不让下面的逻辑执行
        return;
    }

    g_console_input_config.train_start = false;
    if (!isnan(someone_thr))
    {
        g_console_input_config.predict_someone_threshold = someone_thr;
    }
    if (!isnan(move_thr))
    {
        g_console_input_config.predict_move_threshold = move_thr;
    }

    ESP_LOGI(TAG, "校准完成，有人阈值=%.6f，运动阈值=%.6f", g_console_input_config.predict_someone_threshold, g_console_input_config.predict_move_threshold);
}

/* 启动 Ping/NULL 数据 + 雷达算法 */
void start_csi_radar(void)
{
    /* 启动雷达算法 */
    SetIsCsiRadarRunning(true);
    esp_radar_start();
}

/* 关闭 Ping/NULL 数据 + 雷达算法 */
void stop_csi_radar(void)
{
    if (GetIsCsiRadarRunning())
    {
        /* 关闭雷达算法 */
        SetIsCsiRadarRunning(false);
        esp_radar_stop();
        ESP_LOGI(TAG, "系统已停止，实时检测已关闭");
    }
}

bool GetIsPreCalibRunning()
{
    return is_pre_calib_running;
}
bool GetIsStartCalibRunning()
{
    return is_start_calib_running;
}
bool GetIsCsiRadarRunning()
{
    return is_csi_radar_running;
}
void SetIsPreCalibRunning(bool value)
{
    is_pre_calib_running = value;
}
void SetIsStartCalibRunning(bool value)
{
    is_start_calib_running = value;
}
void SetIsCsiRadarRunning(bool value)
{
    is_csi_radar_running = value;
}

void register_human_status_cb(csi_human_status_cb_t cb)
{
    g_human_status_cb = cb;
}